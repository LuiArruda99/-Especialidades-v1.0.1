{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React from 'react';\nimport MapView from \"./MapView\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport var makeOverlays = function makeOverlays(features) {\n  var points = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'point'\n    });\n  });\n  var lines = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polyline'\n    });\n  });\n  var multipolygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'MultiPolygon';\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []);\n  var polygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'Polygon';\n  }).map(function (feature) {\n    return makeOverlay(makeCoordinates(feature), feature);\n  }).reduce(flatten, []).concat(multipolygons).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  return points.concat(lines).concat(polygons);\n};\nvar flatten = function flatten(prev, curr) {\n  return prev.concat(curr);\n};\nvar makeOverlay = function makeOverlay(coordinates, feature) {\n  var overlay = {\n    feature: feature\n  };\n  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n    overlay.coordinates = coordinates[0];\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n  return overlay;\n};\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\nvar makeCoordinates = function makeCoordinates(feature) {\n  var g = feature.geometry;\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(function (p) {\n      return p.map(makeLine);\n    });\n  } else {\n    return [];\n  }\n};\nvar Geojson = function Geojson(props) {\n  var overlays = makeOverlays(props.geojson.features);\n  return _jsx(React.Fragment, {\n    children: overlays.map(function (overlay, index) {\n      if (overlay.type === 'point') {\n        return _jsx(MapView.Marker, {\n          coordinate: overlay.coordinates,\n          pinColor: props.color\n        }, index);\n      }\n      if (overlay.type === 'polygon') {\n        return _jsx(MapView.Polygon, {\n          coordinates: overlay.coordinates,\n          holes: overlay.holes,\n          strokeColor: props.strokeColor,\n          fillColor: props.fillColor,\n          strokeWidth: props.strokeWidth\n        }, index);\n      }\n      if (overlay.type === 'polyline') {\n        return _jsx(MapView.Polyline, {\n          coordinates: overlay.coordinates,\n          strokeColor: props.strokeColor,\n          strokeWidth: props.strokeWidth\n        }, index);\n      }\n    })\n  });\n};\nexport default Geojson;","map":{"version":3,"names":["React","MapView","jsx","_jsx","makeOverlays","features","points","filter","f","geometry","type","map","feature","makeCoordinates","coordinates","makeOverlay","reduce","flatten","overlay","_objectSpread","lines","multipolygons","polygons","concat","prev","curr","length","holes","slice","makePoint","c","latitude","longitude","makeLine","l","g","p","Geojson","props","overlays","geojson","Fragment","children","index","Marker","coordinate","pinColor","color","Polygon","strokeColor","fillColor","strokeWidth","Polyline"],"sources":["/Users/luizclaudioarruda/Desktop/NLW_Happy2.0/mobile/node_modules/react-native-maps/lib/components/Geojson.js"],"sourcesContent":["import React from 'react';\nimport MapView from './MapView';\n\nexport const makeOverlays = features => {\n  const points = features\n    .filter(\n      f =>\n        f.geometry &&\n        (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')\n    )\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map(overlay => ({ ...overlay, type: 'point' }));\n\n  const lines = features\n    .filter(\n      f =>\n        f.geometry &&\n        (f.geometry.type === 'LineString' ||\n          f.geometry.type === 'MultiLineString')\n    )\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map(overlay => ({ ...overlay, type: 'polyline' }));\n\n  const multipolygons = features\n    .filter(f => f.geometry && f.geometry.type === 'MultiPolygon')\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, []);\n\n  const polygons = features\n    .filter(f => f.geometry && f.geometry.type === 'Polygon')\n    .map(feature => makeOverlay(makeCoordinates(feature), feature))\n    .reduce(flatten, [])\n    .concat(multipolygons)\n    .map(overlay => ({ ...overlay, type: 'polygon' }));\n\n  return points.concat(lines).concat(polygons);\n};\n\nconst flatten = (prev, curr) => prev.concat(curr);\n\nconst makeOverlay = (coordinates, feature) => {\n  let overlay = {\n    feature,\n  };\n  if (\n    feature.geometry.type === 'Polygon' ||\n    feature.geometry.type === 'MultiPolygon'\n  ) {\n    overlay.coordinates = coordinates[0];\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n  return overlay;\n};\n\nconst makePoint = c => ({ latitude: c[1], longitude: c[0] });\n\nconst makeLine = l => l.map(makePoint);\n\nconst makeCoordinates = feature => {\n  const g = feature.geometry;\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(p => p.map(makeLine));\n  } else {\n    return [];\n  }\n};\n\nconst Geojson = props => {\n  const overlays = makeOverlays(props.geojson.features);\n  return (\n    <React.Fragment>\n      {overlays.map((overlay, index) => {\n        if (overlay.type === 'point') {\n          return (\n            <MapView.Marker\n              key={index}\n              coordinate={overlay.coordinates}\n              pinColor={props.color}\n            />\n          );\n        }\n        if (overlay.type === 'polygon') {\n          return (\n            <MapView.Polygon\n              key={index}\n              coordinates={overlay.coordinates}\n              holes={overlay.holes}\n              strokeColor={props.strokeColor}\n              fillColor={props.fillColor}\n              strokeWidth={props.strokeWidth}\n            />\n          );\n        }\n        if (overlay.type === 'polyline') {\n          return (\n            <MapView.Polyline\n              key={index}\n              coordinates={overlay.coordinates}\n              strokeColor={props.strokeColor}\n              strokeWidth={props.strokeWidth}\n            />\n          );\n        }\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default Geojson;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}